using AutoMapper;
using Mel.Live.Data;
using Mel.Live.Extensions.UnityExtensions;
using Mel.Live.Models;
using Mel.Live.Models.Entities;
using Mel.Live.Models.Entities.BackOffice;
using Mel.Live.Models.Responses;
using Mel.Live.Models.ViewModels;
using Mel.Live.Services.Interfaces;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace Mel.Live.Controllers
{
    [AutoBuild]
    [ApiController]
    [Route("api/[controller]")]
    public class WalletController : CoreController
    {
        #region Properties

        #region Services
        [DeepDependency]
        IMapper Mapper { get; }

        [DeepDependency]
        ILogger Logger { get; set; }

        [DeepDependency]
        MongoDataContext DataContext { get; set; }

        [DeepDependency]
        UserManager<User> UserManager { get; set; }

        [DeepDependency]
        IPaymentService PaymentService { get; set; }
        #endregion

        #endregion

        #region Methods
        [Authorize]
        [HttpGet("transactions")]
        public async Task<IActionResult> GetTransactions([FromQuery]DateRange range = null)
        {
            if (range.AutoGenerated) range = DateRange.AllTime;

            User user = await UserManager.FindByIdAsync(UserId);

            if (user == null) return Unauthorized();

            var transactions = await DataContext.GetAsync<Transaction>(user.Wallet._Transactions);

            return Ok(Mapper.Map<IEnumerable<TransactionViewModel>>(transactions));
        }


        [HttpGet("deposit/channels")]
        public async Task<IActionResult> GetPaymentChannels()
        {
            var channels = await DataContext.Store.GetAllAsync<PaymentChannel, int>(p => p.Type != ChannelType.Platform && p.IsActive);
            return Ok(Mapper.Map<IEnumerable<PaymentChannelViewModel>>(channels));
        }

        [HttpGet("deposit/accounts")]
        public async Task<IActionResult> GetAccounts()
        {
            var company = await DataContext.Store.GetOneAsync<Company>(c => true);
            return Ok(Mapper.Map<IEnumerable<BankAccount>>(company.BankAccounts));
        }

        [Authorize]
        [HttpPost("deposit")]
        public async Task<IActionResult> Deposit(DepositViewModel model)
        {
            User user = await UserManager.FindByIdAsync(UserId);

            if (user == null) return Unauthorized();

            PaymentResult result = null;
            switch ((ChannelType)model.Channel)
            {
                case ChannelType.Paystack:
                    result = await PaymentService.UsePaystack(user, model.Amount);
                    break;

                case ChannelType.Bank:
                    if (!user.BankAccounts.Any(b => b.IsActive && b.Id == model.BankAccountId))
                        return NotFound("No bank account was found with the provided Id");
                    else if (!DataContext.Company.BankAccounts.Any(b => b.IsActive && b.Id == model.CompanyBankAccountId))
                        return NotFound("No company bank account was found with the provided Id");

                    var request = Mapper.Map<BankTransactionRequest>(model);
                    request.User = user;

                    result = await PaymentService.UseBank(request, PaymentType.Deposit);
                    break;
            }

            switch (result.Status)
            {
                case PaymentStatus.Redirected:
                    return Accepted(result.Message, result.Message);
                case PaymentStatus.Success:
                    return Ok();
                case PaymentStatus.Pending:
                    return Accepted();

                default: return BadRequest(result.Message);
            }
        }

        [Authorize]
        [HttpPost("withdraw")]
        public async Task<IActionResult> Withdraw(WithdrawalViewModel model)
        {
            User user = await UserManager.FindByIdAsync(UserId);

            if (user == null) return Unauthorized();

            if (model.Amount > user.Wallet.AvailableBalance) return BadRequest("Insufficient funds");
            if (!user.BankAccounts.Any(b => b.IsActive && b.Id == model.BankAccountId))
                return NotFound("No bank account was found with the provided Id");

            var request = Mapper.Map<BankTransactionRequest>(model);
            request.User = user;

            PaymentResult result = await PaymentService.UseBank(request, PaymentType.Withdrawal);
            
            switch (result.Status)
            {
                case PaymentStatus.Pending:
                    return Accepted();

                default: return BadRequest(result.Message);
            }
        }
        #endregion
    }
}
